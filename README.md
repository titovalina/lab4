# Титова Алина ИТ-7 Лабораторная №4 (1 вариант)

# Задание 1.
## 2. Без null
### Текст задачи
Создайте сущность Хранилище, которая обладает следующими характеристиками:
* Может хранить один произвольный объект в один момент времени.
* Хранилище неизменяемо.
* Объект кладется в Хранилище при его создании. В качестве объекта может быть сохранено также и значение null.
* Хранилище может вернуть ссылку на Объект.
* Если вместо объекта хранится null, необходимо вернуть какое-либо альтернативное значение.
* Метод получения значения должен работать с тем типом данных, который был указан во время создания объекта
Выполните следующие задания:
* Создайте Хранилище чисел, положите туда значение null. Передайте Хранилище в какойлибо метод, извлеките значение, и выведите его на экран. Альтернативой должно быть число 0.
* Создайте Хранилище чисел, положите туда значение 99. Передайте Хранилище в какойлибо метод, извлеките значение, и выведите его на экран. Альтернативой должно быть число -1.
* Создайте Хранилище строк, положите туда значение null. Передайте Хранилище в какойлибо метод, извлеките значение, и выведите его на экран. Альтернативой должна быть строка “default”.
* Создайте Хранилище строк, положите туда значение “hello”. Передайте Хранилище в какой-либо метод, извлеките значение, и выведите его на экран. Альтернативой должна быть строка “hello world”.
<img width="795" height="169" alt="image" src="https://github.com/user-attachments/assets/f770c20f-91a2-49f7-9aee-a1c835a1a1c3" />

### Алгоритм решения
1. Создаём класс Storage<T> с обобщённым типом T, который может хранить любой объект.
2. Хранилище неизменяемое: значение передаётся только через конструктор (private final T value).
3. Метод getOrElse(T alternative):
* Если в хранилище есть значение (не null) → возвращаем его.
* Если значение null → возвращаем альтернативное значение.
4. В main (метод demonstrateStorage) создаём 4 варианта хранилища:
* Число null → выводим 0
* Число 99 → выводим 99 (альтернатива -1 игнорируется, так как есть значение)
* Строка null → выводим "default"
* Строка "hello" → выводим "hello" (альтернатива "hello world" игнорируется)

## 5. Обобщенная линия
### Текст задачи
Измените сущность Линия из задачи 2.6.3, таким образом, чтобы
* При создании её объекта можно было точно указать тип точки, на которой расположена линия: двухмерная или трехмерная (из задачи 2.3.5).
* Методы получения и установки значения Точки также могли работать с типом указанным при создании объекта.
* Граница стирания не может быть хуже двумерной точки.
Создайте и выведите на экран произвольную линию в трехмерном пространстве
<img width="1024" height="568" alt="image" src="https://github.com/user-attachments/assets/96902947-9a57-4522-b41a-c350b0ac65ce" />

### Алгоритм решения
1. Создание точек:
* Point2D и Point3D имеют координаты.
* Point3D наследует Point2D и добавляет координату z.
2. Создание линии:
* Класс Line<T extends Point2D> — обобщённая линия.
* Принимает два объекта T (начало и конец).
* Методы getStartPoint() и getEndPoint() позволяют работать с точками.
3. Длина линии (getLengthInt):
* Вычисляется по формуле расстояния в 2D или 3D.
* Проверка через instanceof для определения, нужно ли учитывать z.
* Возвращается целое число (int) округлённое.

# Задание 2.
## 1. Сдвинуть линию
### Текст задачи
Создайте метод, принимающий Линию из задачи 3.1.5 (с любой допустимой параметризацией) сдвигающей точку начала на 10 единиц по оси X. Например, если X был 5, то должен стать 15, если X был -7, то должен стать -17.
<img width="1024" height="568" alt="image" src="https://github.com/user-attachments/assets/96902947-9a57-4522-b41a-c350b0ac65ce" />

### Алгоритм решения
1. Принимаем Line<T extends Point2D>.
2. Получаем start и end точки.
3. Определяем смещение: если x >= 0 → +10, иначе → -10.
4. Создаём новые точки с изменённой координатой X.
5. Подставляем их обратно в линию (setStartPoint, setEndPoint).

# Задание 3.
## 1. Функция
### Текст задачи
Разработайте такой метод, который будет принимать список значений типа T, и объект имеющий единственный метод apply. Данный метод надо применить к каждому элементу списка, и вернуть новый список значений типа P, при этом типы T и P могут совпадать, а могут не совпадать.
Используйте разработанный метод следующим образом:
1. Передайте в метод список со значениями:“qwerty”, “asdfg”, “zx”, а получите список чисел, где каждое число соответствует длине каждой строки.
2. Передайте в метод список со значениями: 1,-3,7, а получите список в котором все отрицательные числа стали положительными, а положительные остались без изменений
3. Передайте в метод список состоящий из массивов целых чисел, а получите список в котором будут только максимальные значения каждого из исходных массивов
<img width="570" height="136" alt="image" src="https://github.com/user-attachments/assets/41c705b3-123a-4911-bcc5-34dbd6b89101" />

### Алгоритм решения
1. Принимаем список List<T> и объект Mapper<T,P> (объект с единственным методом apply).
2. Создаём новый список List<P> для результата.
3. Проходим по каждому элементу входного списка и применяем mapper.apply(item).
4. Добавляем результат в новый список.
5. Возвращаем новый список.
6. Применение в Main:
* Список строк → получаем список их длин.
* Список чисел → делаем отрицательные числа положительными.
* Список массивов → выбираем максимальное значение в каждом массиве.

## 2. Фильтр
### Текст задачи
Разработайте такой метод, который будет принимать список значений типа T и объект имеющий единственный метод test (принимает T и возвращает boolean). Верните новый список типа T, из которого удалены все значения не прошедшие проверку условием.
Используйте разработанный метод следующим образом:
1. Передайте в метод список со значениями: “qwerty”, “asdfg”, “zx”, и отфильтруйте все строки имеющие менее трех символов
2. Передайте в метод список со значениями: 1,-3,7, и отфильтруйте все положительные элементы
3. Передайте в метод список состоящий из массивов целых чисел, а получите список в котором будут только те массивы, в которых нет ни одного положительного элемента
<img width="605" height="138" alt="image" src="https://github.com/user-attachments/assets/c308b585-32f2-478a-9a42-b6096c91ac13" />

### Алгоритм решения
1. Принимаем список List<T> и объект Tester<T> (с единственным методом test).
2. Создаём пустой список result.
3. Проходим по каждому элементу:
* Если tester.test(item) вернуло true → добавляем в result.
* Иначе — пропускаем.
4. Возвращаем новый список.
5. Применение:
* Строки: фильтруем по длине ≥ 3.
* Числа: фильтруем отрицательные.
* Массивы: оставляем только те, где нет положительных чисел.

## 3. Сокращение
### Текст задачи
Разработайте такой метод, который будет принимать список значений типа T и способ с помощью которого список значений можно свести к одному значению типа T, которое и возвращается из метода.
Используйте разработанный метод следующим образом:
1. Передайте в метод список со значениями: “qwerty”, “asdfg”, “zx”, и сформируйте одну большую строку, которая состоит из всех строк исходного списка.
2. Передайте в метод список со значениями: 1,-3,7, и верните сумму всех значений исходного списка.
3. Имеется список, состоящий из списков целых чисел, получите общеe количество элементов во всех списках. Подсказка: решить задачу можно в одно действие или последовательно использовать методы из 3.3.1 и 3.3.3.
Далее необходимо изменить разработанный метод таким образом, чтобы данный метод гарантированно не возвращал null и не выбрасывал ошибок в том случае, если исходный список пуст.
<img width="759" height="136" alt="image" src="https://github.com/user-attachments/assets/57a8a889-a62a-4520-8308-725db080b7e3" />

### Алгоритм решения
1. Принимаем список List<T>, бинарный оператор BinaryOperator<T> и значение identity.
2. Инициализируем результат result = identity.
3. Проходим по каждому элементу списка и комбинируем через combiner.apply(result, item).
4. Возвращаем результат.
5. Применение:
* Склеиваем строки → создаём одну большую строку.
* Суммируем числа → получаем сумму.
* Считаем общее количество элементов в списках → суммируем размеры списков.

## 4. Коллекционирование
### Текст задачи
Разработайте такой метод, который будет возвращать коллекцию типа P со значениями типа T.
Данный метод будет принимать:
1. Список исходных значений
2. Способ создания результирующей коллекции
3. Способ передачи значений исходного списка в результирующую коллекцию.
Используйте разработанный метод следующим образом:
1. Передайте в метод список со значениями: 1,-3,7, и верните их разбитыми на два подсписка, в одном из которых будут только положительные числа, а в другом только отрицательные.
2. Передайте в метод список со значениями: “qwerty”, “asdfg”, “zx”, “qw” и верните их разбитыми на подсписки таким образом, чтобы в любом подсписке были строки только одинаковой длины
3. Передайте в метод список со значениями: “qwerty”, “asdfg”, “qwerty”, “qw” и верните набор такого вида, который не может содержать одинаковые объекты.
<img width="864" height="140" alt="image" src="https://github.com/user-attachments/assets/a60e09fc-1b0b-40b7-b683-439d7f6d525a" />

### Алгоритм решения
1. Принимаем список исходных значений List<T>.
2. Принимаем:
* Supplier<P> — способ создания результирующей коллекции.
* Function<List<T>, P> — способ переноса элементов.
3. Возвращаем результат работы collectorFunction.apply(list).
4. Применение в Main:
* Разделяем числа на положительные и отрицательные → Map<String, List<Integer>>.
* Разделяем строки по длине → Map<Integer, List<String>>.
* Убираем дубликаты → Set<String>.
